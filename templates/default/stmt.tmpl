package {{ .PackageName }}

import (
  "fmt"
  "context"
  "text/template"
  "database/sql"
  "bytes"
  "time"

  "github.com/jmoiron/sqlx"
  null "gopkg.in/volatiletech/null.v6"
)

var (
  // Suppress "imported and not used" errors.
  _ = fmt.Printf
  _ = context.Background
  _ = template.IsTrue
  _ = sql.Open
  _ = sqlx.Named
  _ = null.NewBool
  _ = bytes.NewBuffer
  _ = time.Now
)

{{ range $stmt := .Stmts }}

  {{ $name := $stmt.StmtName }}
  {{ $uname := $stmt.UName }}
  {{ $type := $stmt.StmtType }}
  {{ $args := ExtractArgsInfo $stmt}}
  {{ $vars := ExtractVarsInfo $stmt}}
  {{ $wcs := ExtractWildcardsInfo $stmt}}

  {{ $flagSingleWildcard := $wcs.SingleWildcard }}
  {{ $flagHasWildcard := gt (len $wcs.Wildcards) 0 }}
  {{ $flagUseTemplate := $vars.Has "use_template" }}
  {{ $flagInQuery := $vars.Has "in_query" }}
  {{ $flagReturnOne := eq ($vars.Value "return") "one" }}

  {{ if eq $type "SELECT"}}

    {{ $resultName := Ternary $flagSingleWildcard (UpperCamel (index $wcs.Wildcards 0).Table.TableName) (printf "%sResult" $uname) }}

    {{ if not $flagSingleWildcard }}

// {{ $resultName }} is the result of {{ $uname }}.
type {{ $resultName }} struct {
      {{ range $i, $col := $stmt.QueryResultCols -}}
        {{ $wc := $wcs.ResultCol2Wildcard $i -}}
        {{ $wcCol := $wcs.ResultCol2WildcardCol $i -}}
        {{ if $wcCol.Valid -}}
          {{ if eq $wcCol.Pos 0 -}}
  {{ $wc.UName }} *{{ $wcCol.Table.UName }}
          {{ end -}}
        {{ else -}}
  {{ UpperCamel $col.Name }} {{ ScanType $col }}
        {{ end -}}
      {{ end -}}

      {{ range $wc := $wcs.Wildcards -}}
  nxNull{{ $wc.UName }} nxNull{{ $wc.Table.UName }}
      {{ end -}}
}

func (result *{{ $resultName }}) nxPreScan(dest *[]interface{}) {
      {{ range $i, $col := $stmt.QueryResultCols -}}
        {{ $wc := $wcs.ResultCol2Wildcard $i -}}
        {{ $wcCol := $wcs.ResultCol2WildcardCol $i -}}
        {{ if $wcCol.Valid -}}
          {{ if eq $wcCol.Pos 0 -}}
  result.nxNull{{ $wc.UName }}.nxPreScan(dest)
          {{ end -}}
        {{ else -}}
  *dest = append(*dest, &result.{{ UpperCamel $col.Name }})
        {{ end -}}
      {{ end -}}
}

func (result *{{ $resultName }}) nxPostScan() error {
      {{ range $wc := $wcs.Wildcards -}}
  if err := result.nxNull{{ $wc.UName }}.nxPostScan(); err != nil {
    return err
  }
  result.{{ $wc.UName }} = result.nxNull{{ $wc.UName }}.Ordinary()
      {{ end }}
  return nil
}

      {{ if and (not $flagReturnOne) $flagHasWildcard }}

// {{ $resultName }}Slice is slice of {{ $resultName }}.
type {{ $resultName }}Slice []*{{ $resultName }}

// nx{{ $resultName }}Slices is slice of {{ $resultName }}Slice.
type nx{{ $resultName }}Slices []{{ $resultName }}Slice

func (slice *{{ $resultName }}Slice) nxLen() int {
  return len(*slice)
}

func (slice *{{ $resultName }}Slice) nxItem(i int) interface{} {
  return (*slice)[i]
}

func (slice *{{ $resultName }}Slice) nxAppend(item interface{}) {
  obj := (*{{ $resultName }})(nil)
  if item != nil {
    obj = item.(*{{ $resultName }})
  }
  *slice = append(*slice, obj)
}

func (slice *{{ $resultName }}Slice) One() *{{ $resultName }} {
  if len(*slice) != 1 {
    panic(fmt.Errorf("{{ $resultName }}Slice.One has %d rows", len(*slice)))
  }
  return (*slice)[0]
}
  
        {{ range $wc := $wcs.Wildcards }}{{ if $wc.Table.Primary.Valid }}
func (slice *{{ $resultName }}Slice) Distinct{{ $wc.UName }}() ([]*{{ $wc.Table.UName }}, []{{ $resultName }}Slice) {
  trs := nx{{ $wc.Table.UName }}Slice{}
  groups := nx{{ $resultName }}Slices{}
  groupBy(slice, func(item interface{}) TableRowWithPrimary {
    return item.(*{{ $resultName }}).{{ $wc.UName }}
  }, &trs, &groups)
  return trs, groups
}
        {{ end }}{{ end }}

func (slices *nx{{ $resultName }}Slices) nxLen() int {
  return len(*slices)
}

func (slices *nx{{ $resultName }}Slices) nxSlicer(i int) Slicer {
  return &((*slices)[i])
}

func (slices *nx{{ $resultName }}Slices) nxAppend() {
  *slices = append(*slices, nil)
}

      {{ end }} {{/*{{ if and (not $flagReturnOne) $flagHasWildcard }}*/}}

    {{ end }} {{/*{{ if not $flagSingleWildcard }}*/}}
      
/*
{{ $uname }} is created from:

  {{ Replace $stmt.StmtSrc "\n" "\n  " }}
*/
func {{ $uname }}(ctx context.Context, q Queryer{{ range $arg := $args.Args }}, {{ $arg.ArgName }} {{ $arg.ArgType }}{{ end }}) ({{ if $flagReturnOne }}*{{ $resultName }}{{ else }}{{ $resultName }}Slice{{ end }}, error) {
  // NOTE: Add a nested block to allow identifier shadowing.
  {
    // Build query.
    query, args, err := nxBuild{{ $uname }}Query(map[string]interface{}{
      {{ range $arg := $args.Args -}}
      "{{ $arg.ArgName }}": {{ $arg.ArgName }},
      {{ end -}}
    })
    if err != nil {
      return nil, err
    }

      {{ if $flagReturnOne }}
    // Query.
    row := q.QueryRowContext(ctx, query, args...)

    // Fill scan pointers.
    pointers := make([]interface{}, 0, {{ $stmt.NumQueryResultCol }})
    result := &{{ $resultName }}{}
    result.nxPreScan(&pointers)

    // Scan.
    err = row.Scan(pointers...)
    if err != nil {
      if err == sql.ErrNoRows {
        return nil, nil
      }
      return nil, err
    }

    // Post scan process.
    if err := result.nxPostScan(); err != nil {
      return nil, err
    }
    return result, nil

      {{ else }} {{/*{{ if $flagReturnOne }}*/}}
    // Query.
    rows, err := q.QueryContext(ctx, query, args...)
    if err != nil {
      return nil, err
    }
    defer rows.Close()

    // Scan.
    results := []*{{ $resultName }}{}
    pointers := make([]interface{}, 0, {{ $stmt.NumQueryResultCol }})
    for rows.Next() {
      // Fill scan pointers.
      pointers = pointers[0:0]
      result := &{{ $resultName }}{}
      result.nxPreScan(&pointers)

      // Scan.
      err = rows.Scan(pointers...)
      if err != nil {
        return nil, err
      }

      // Post scan process.
      if err := result.nxPostScan(); err != nil {
        return nil, err
      }
      results = append(results, result)
    }
    return results, nil

      {{ end }} {{/*{{ if $flagReturnOne }}*/}}

  }

}

  {{ else }} {{/*{{ if eq $type "SELECT"}}*/}}


  {{ end }} {{/*{{ if eq $type "SELECT"}}*/}}

var (
  {{ if $flagUseTemplate -}}
  nx{{ $uname }}QueryTmpl = template.Must(template.New("{{ $uname }}").Parse({{ printf "%+q" $stmt.Text }}))
  {{ else -}}
  nx{{ $uname }}Query = {{ printf "%+q" $stmt.Text }}
  {{ end -}}
)

func nxBuild{{ $uname }}Query(data map[string]interface{}) (string, []interface{}, error) {
  {{ if $flagUseTemplate }}
  // Template -> named query.
  buf := bytes.Buffer{}
  if err := nx{{ $uname }}QueryTmpl.Execute(&buf, data); err != nil {
    return "", nil, err
  }
  namedQuery := buf.String()
  {{ else }}
  // Named query.
  namedQuery := nx{{ $uname }}Query
  {{ end }}

  // Named query -> query.
  query, args, err := sqlx.Named(namedQuery, data)
  if err != nil {
    return "", nil, err
  }

  {{ if $flagInQuery }}
  // Expand "in" args.
  query, args, err = sqlx.In(query, args...)
  if err != nil {
    return "", nil, err
  }
  {{ end }}

  return query, args, nil
}


{{ end }} {{/*{{ range $stmt := .Stmts }}*/}}


