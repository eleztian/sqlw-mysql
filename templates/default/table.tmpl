package {{ .PackageName }}


import (
  "context"
  "fmt"
  "strings"
  "time"
  "database/sql"

  "gopkg.in/volatiletech/null.v6"
)

// Suppress not used errors.
var (
  _ = context.Background
  _ = fmt.Printf
  _ = strings.Join
  _ = time.Now
  _ = null.NewBool
)

{{ $name := .Table.TableName }}
{{ $uname := .Table.UName }}

// {{ $uname }} represents a row of table `{{ $name }}`.
type {{ $uname }} struct {
  {{ range $col := .Table.Columns -}}
  {{ $col.UName }} {{ ScanType $col }} `json:"{{ $col.ColumnName }}" db:"{{ $col.ColumnName }}"` {{ if $col.HasDefaultValue }}// Has default.{{ end }}
  {{ end -}}
}

{{ if .Table.Primary.Valid -}}
// nx{{ $uname }}PrimaryValue is the primary value of {{ $uname }}.
type nx{{ $uname }}PrimaryValue struct {
  {{ range $col := .Table.Primary.Columns -}}
  {{ $col.UName }} {{ ScanType $col }}
  {{ end -}}
}
{{ end }}

// nxNull{{ $uname }} is nullable version of {{ $uname }}. 
// It's mainly used for scanning row which maybe NULL (e.g. in outer join).
type nxNull{{ $uname }} struct {
  ordinary *{{ $uname }}
  nx{{ $uname }} {{ $uname }}
  {{ range $col := .Table.Columns -}}{{ if not $col.Nullable -}}
  null{{ $col.UName }} {{ NullScanType $col }} // For scanning column `{{ $col.ColumnName }}`
  {{ end -}}{{ end -}}
}

// {{ $uname }}Slice is slice of {{ $uname }}.
type {{ $uname }}Slice []*{{ $uname }}

// nxPreScan appends all columns to dest for scanning. Implements ColumnScanner interface.
func (tr *{{ $uname }}) nxPreScan(dest *[]interface{}) {
  *dest = append(*dest,
  {{ range $col := .Table.Columns -}}
    &tr.{{ $col.UName }},
  {{ end -}}
  )
}

// nxPostScan do nothing. Implements ColumnScanner interface.
func (tr *{{ $uname }}) nxPostScan() error { 
  return nil 
}

var (
  nx{{ $uname }}Meta = NewTableMeta(
    "{{ $name }}",
    []string{ {{- range $col := .Table.Columns }}"{{ $col.ColumnName }}", {{ end -}} },
    OptColumnsWithDefault({{ range $col := .Table.Columns }}{{ if $col.HasDefaultValue }}"{{ $col.ColumnName }}", {{ end }}{{ end }}),
    {{ if .Table.Primary.Valid -}}
    OptPrimaryColumns({{ range $col := .Table.Primary.Columns }}"{{ $col.ColumnName }}", {{ end }}),
    {{ end -}}
    {{ if .Table.AutoIncColumn.Valid -}}
    OptAutoIncColumn("{{ .Table.AutoIncColumn.ColumnName }}"),
    {{ end -}}
  )
)

// TableMeta returns the table meta information of table `{{ $name }}`. Implements TableRow interface.
func (tr *{{ $uname }}) TableMeta() *TableMeta {
  return nx{{ $uname }}Meta
}

// Valid returns true if this is a valid table row (e.g. not NULL). Implements TableRow interface.
func (tr *{{ $uname }}) Valid() bool {
  return tr != nil
}

// ColumnValue returns the i-th column's value. Implements TableRow interface.
func (tr *{{ $uname }}) ColumnValue(i int) interface{} {
  switch i {
  {{ range $i, $col := .Table.Columns -}}
  case {{ $i }}:
    return tr.{{ $col.UName }}
  {{ end -}}
  default:
    panic(fmt.Errorf("{{ $uname }}.ColumnValue: %d out of range", i))
  }
}

// ColumnPointer returns the i-th column's pointer. Implements TableRow interface.
func (tr *{{ $uname }}) ColumnPointer(i int) interface{} {
  switch i {
  {{ range $i, $col := .Table.Columns -}}
  case {{ $i }}:
    return &tr.{{ $col.UName }}
  {{ end -}}
  default:
    panic(fmt.Errorf("{{ $uname }}.ColumnPointer: %d out of range", i))
  }
}

// Copy the row.
func (tr *{{ $uname }}) Copy() *{{ $uname }} {
  ret := &{{ $uname }}{}
  *ret = *tr
  return ret
}

{{ if .Table.Primary.Valid -}}
// PrimaryValue returns the primary key value of this row. Implements TableRowWithPrimary interface.
func (tr *{{ $uname }}) PrimaryValue() interface{} {
  if tr == nil {
    return nil
  }
  return nx{{ $uname }}PrimaryValue{
    {{ range $col := .Table.Primary.Columns -}}
    {{ $col.UName }}: tr.{{ $col.UName }},
    {{ end -}}
  }
}
{{ end -}}

// Insert is used to insert the row into table.
// This method will also update the value in auto increment column (if exists).
func (tr *{{ $uname }}) Insert(ctx context.Context, e Execer) error {
  return insertTR(ctx, e, tr, "")
}

// InsertEx is the same as Insert with extra modifier specified.
// modifier can be one of:
//   - "ignore": "INSERT IGNORE INTO ..."
//   - "replace": "REPLACE INTO ..."
//   - "": Normal "INSERT INTO ..."
func (tr *{{ $uname }}) InsertEx(ctx context.Context, e Execer, modifier string) error {
  return insertTR(ctx, e, tr, modifier)
}

{{ if .Table.Primary.Valid -}}
// Reload is used to reload the row from table. It returns error if no row is found.
func (tr *{{ $uname }}) Reload(ctx context.Context, q Queryer) error {
  return selectTR(ctx, q, tr, false)
}
{{ end }}

{{ if .Table.Primary.Valid -}}
// ReloadWithLock is used to reload this row with lock from table. It returns error if no row is found.
func (tr *{{ $uname }}) ReloadWithLock(ctx context.Context, q Queryer) error {
  return selectTR(ctx, q, tr, true)
}
{{ end }}

{{ if .Table.Primary.Valid -}}
// Update is used to update the row in table. Only columns with different values will be updated.
// NOTE: This method does not modify content in `tr`/`newTr`. Use Reload to load fresh data from database.
func (tr *{{ $uname }}) Update(ctx context.Context, e Execer, newTr *{{ $uname }}) error {
  return updateTR(ctx, e, tr, newTr)
}
{{ end }}

{{ if .Table.Primary.Valid -}}
// Delete is used to delete the row from table.
func (tr *{{ $uname }}) Delete(ctx context.Context, e Execer) error {
  return deleteTR(ctx, e, tr)
}
{{ end }}

{{ range $fk := .Table.FKs -}}
  {{ $refTable := $fk.RefTable -}}
  {{ $refIndex := $fk.RefUniqueIndex -}}
  {{ if $refIndex.Valid -}}
// {{ $refTable.UName }}By{{ $fk.UName }} returns the associated {{ $refTable.UName }} by `{{ $fk.FKName }}` foreign key.
func (tr *{{ $uname }}) {{ $refTable.UName }}By{{ $fk.UName }}(ctx context.Context, q Queryer, lock bool) (*{{ $refTable.UName }}, error) {
  {{ range $col := $fk.Columns -}}
    {{ if $col.Nullable -}}
  if !tr.{{ $col.UName }}.Valid {
    return nil, nil
  } 
  {{ $col.LName }} := tr.{{ $col.UName }}.{{ Slice (NullScanType $col) 5 }}
    {{ else -}}
  {{ $col.LName }} := tr.{{ $col.UName }}
    {{ end -}}
  {{ end }}

  return {{ $refTable.UName }}By{{ $refIndex.UName }}(ctx, q{{ range $col := $fk.Columns }}, {{ $col.LName }}{{ end }}, lock)
}
  {{ end -}}
{{ end -}}

{{ range $index := .Table.Indices -}}
  {{ if $index.IsUnique -}}
// {{ $uname }}By{{ $index.UName }} is used to select {{ $uname }} by `{{ $index.IndexName }}` index.
// It returns nil if no row is found.
func {{ $uname }}By{{ $index.UName }}(ctx context.Context, q Queryer{{ range $col := $index.Columns }}, {{ $col.LName }} {{ NotNullScanType $col }}{{ end }}, lock bool) (*{{ $uname }}, error){
  tr := {{ $uname }}{}
  if err := selectTRCond(ctx, q, &tr, lock, "1{{ range $col := $index.Columns }} AND `{{ $col.ColumnName }}`=?{{ end }}",
    {{- range $col := $index.Columns -}}
    {{ $col.LName }},
    {{- end -}}
  ); err != nil {
    if err == sql.ErrNoRows {
      err = nil
    }
    return nil, err
  }
  return &tr, nil
}
  {{ end -}}
{{ end }}

// nxPreScan appends all columns to dest for scanning. Implements ColumnScanner interface.
func (tr *nxNull{{ $uname }}) nxPreScan(dest *[]interface{}) {
  *dest = append(*dest,
  {{ range $i, $col := .Table.Columns -}}
  {{ if $col.Nullable -}}
    &tr.nx{{ $uname }}.{{ $col.UName }},
  {{ else -}}
    &tr.null{{ $col.UName }},
  {{ end -}}
  {{ end -}}
  )
}

// nxPostScan must be called after scanning to do some extra processsing. Implements ColumnScanner interface.
func (tr *nxNull{{ $uname }}) nxPostScan() error {

  var nullCol string

  {{ range $col := .Table.Columns -}}
  {{ if not $col.Nullable -}}
  if !tr.null{{ $col.UName }}.Valid {
    nullCol = "{{ $col.ColumnName }}"
    goto CheckNULL
  }
  tr.nx{{ $uname }}.{{ $col.UName }} = tr.null{{ $col.UName }}.{{ Slice (NullScanType $col) 5 }}

  {{ end -}}
  {{ end -}}

  if false {
    // NOTE: Impossible branch to suppress "label CheckNULL defined and not used" error.
    goto CheckNULL
  }

  // All checks passed
  tr.ordinary = &tr.nx{{ $uname }}
  return nil

CheckNULL:
  if *tr == (nxNull{{ $uname }}{}) {
    // Null row, set ptr to nil.
    tr.ordinary = nil
    return nil
  }
  return fmt.Errorf("{{ $name }}.%s can't be NULL", nullCol)
}


// Ordinary returns the ordinary {{ $uname }}. It must be called only after nxPostScan.
func (tr *nxNull{{ $uname }}) Ordinary() *{{ $uname }} {
  return tr.ordinary
}

func (slice *{{ $uname }}Slice) nxLen() int {
  return len(*slice)
}

func (slice *{{ $uname }}Slice) nxItem(i int) interface{} {
  return (*slice)[i]
}

func (slice *{{ $uname }}Slice) nxAppend(item interface{}) {
  if item == nil {
    *slice = append(*slice, &{{ $uname }}{})
  } else {
    *slice = append(*slice, item.(*{{ $uname }}))
  }
}

