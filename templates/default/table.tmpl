package {{ .PackageName }}


import (
  "context"
  "fmt"
  "time"

  "gopkg.in/volatiletech/null.v6"
)

// Suppress not used errors.
var (
  _ = context.Background
  _ = fmt.Printf
  _ = time.Now
  _ = null.NewBool
)

{{ $name := .Table.TableName }}
{{ $uname := .Table.UName }}

// {{ $uname }} represents a row of table `{{ $name }}`.
type {{ $uname }} struct {
  {{ range $col := .Table.Columns -}}
  {{ $col.UName }} {{ ScanType $col }} `json:"{{ $col.ColumnName }}" db:"{{ $col.ColumnName }}"`
  {{ end -}}
}

{{ if .Table.Primary.Valid -}}
// nx{{ $uname }}PrimaryValue is the primary value of {{ $uname }}.
type nx{{ $uname }}PrimaryValue struct {
  {{ range $col := .Table.Primary.Columns -}}
  {{ $col.UName }} {{ ScanType $col }}
  {{ end -}}
}
{{ end }}

// nxNull{{ $uname }} is nullable version of {{ $uname }}. It's mainly used for scanning row which maybe NULL (e.g. in outer join).
type nxNull{{ $uname }} struct {
  ordinary {{ $uname }}
  ordinaryPtr *{{ $uname }}
  {{ range $col := .Table.Columns -}}{{ if not $col.Nullable -}}
  null{{ $col.UName }} {{ NullScanType $col }}
  {{ end -}}{{ end -}}
}

// nx{{ $uname }}Slice is slice of {{ $uname }}.
type nx{{ $uname }}Slice []*{{ $uname }}

var (
  nx{{ $uname }}Meta = NewTableMeta(
    "{{ $name }}",
    []string{ {{- range $col := .Table.Columns }}"{{ $col.ColumnName }}", {{ end -}} },
    OptColumnsWithDefault({{ range $col := .Table.Columns }}{{ if $col.HasDefaultValue }}"{{ $col.ColumnName }}", {{ end }}{{ end }}),
    {{ if .Table.Primary.Valid -}}
    OptPrimaryColumns({{ range $col := .Table.Primary.Columns }}"{{ $col.ColumnName }}", {{ end }}),
    {{ end -}}
    {{ if .Table.AutoIncColumn.Valid -}}
    OptAutoIncColumn("{{ .Table.AutoIncColumn.ColumnName }}"),
    {{ end -}}
  )
)

// nxPreScan appends all columns to dest for scanning. Implements ColumnScanner interface.
func (tr *{{ $uname }}) nxPreScan(dest *[]interface{}) {
  *dest = append(*dest,
  {{ range $col := .Table.Columns -}}
    tr.{{ $col.UName }},
  {{ end -}}
  )
}

// nxPostScan do nothing. Implements ColumnScanner interface.
func (tr *{{ $uname }}) nxPostScan() error { 
  return nil 
}

// TableMeta returns the table meta information of table `{{ $name }}`. Implements TableRow interface.
func (tr *{{ $uname }}) TableMeta() *TableMeta {
  return nx{{ $uname }}Meta
}

// Valid returns true if this is a valid table row (e.g. not NULL). Implements TableRow interface.
func (tr *{{ $uname }}) Valid() bool {
  return tr != nil
}

// ColumnValue returns the i-th column value of table `{{ $name }}`. Implements TableRow interface.
func (tr *{{ $uname }}) ColumnValue(i int) interface{} {
  switch i {
  {{ range $i, $col := .Table.Columns -}}
  case {{ $i }}:
    return tr.{{ $col.UName }}
  {{ end -}}
  default:
    panic(fmt.Errorf("{{ $uname }}.ColumnValue: %d out of range", i))
  }
}

// ColumnPointe returns the i-th column's pointer of table `{{ $name }}`. Implements TableRow interface.
func (tr *{{ $uname }}) ColumnPointer(i int) interface{} {
  switch i {
  {{ range $i, $col := .Table.Columns -}}
  case {{ $i }}:
    return &tr.{{ $col.UName }}
  {{ end -}}
  default:
    panic(fmt.Errorf("{{ $uname }}.ColumnPointer: %d out of range", i))
  }
}

{{ if .Table.Primary.Valid -}}
// PrimaryValue returns the primary key value of this row. Implements TableRowWithPrimary interface.
func (tr *{{ $uname }}) PrimaryValue() interface{} {
  if tr == nil {
    return nil
  }
  return nx{{ $uname }}PrimaryValue{
    {{ range $col := .Table.Primary.Columns -}}
    {{ $col.UName }}: tr.{{ $col.UName }},
    {{ end -}}
  }
}
{{ end -}}

// Insert is used to insert this row into table.
// NOTE: This method does not modify content in `tr` except auto increment column (if exists).
{{ if .Table.Primary.Valid -}}
// Use Reload to get the newest data from database.
{{ end -}}
func (tr *{{ $uname }}) Insert(ctx context.Context, e Execer) error {
  return insertTR(ctx, e, tr)
}

{{ if .Table.Primary.Valid -}}
// Reload is used to reload this row from table.
func (tr *{{ $uname }}) Reload(ctx context.Context, q Queryer) error {
  return selectTR(ctx, q, tr, false)
}
{{ end }}

{{ if .Table.Primary.Valid -}}
// ReloadWithLock is used to reload this row with lock from table.
func (tr *{{ $uname }}) ReloadWithLock(ctx context.Context, q Queryer) error {
  return selectTR(ctx, q, tr, true)
}
{{ end }}

{{ if .Table.Primary.Valid -}}
// Update is used to update this row in table. Only columns with different values will be updated.
// NOTE: This method does not modify content in `tr`/`newTr`. 
// Use Reload to get the newest data from database.
func (tr *{{ $uname }}) Update(ctx context.Context, e Execer, newTr *{{ $uname }}) error {
  return updateTR(ctx, e, tr, newTr)
}
{{ end }}

{{ if .Table.Primary.Valid -}}
// Delete is used to delete this row from table.
func (tr *{{ $uname }}) Delete(ctx context.Context, e Execer) error {
  return deleteTR(ctx, e, tr)
}
{{ end }}

// Copy this row.
func (tr *{{ $uname }}) Copy() *{{ $uname }} {
  ret := &{{ $uname }}{}
  *ret = *tr
  return ret
}

{{ range $index := .Table.Indices -}}
{{ if $index.IsUnique -}}
// {{ $uname }}By{{ $index.UName }} is used to select `{{ $name }}` row by key `{{ $index.IndexName }}`.
func {{ $uname }}By{{ $index.UName }}(ctx context.Context, q Queryer{{ range $col := $index.Columns }}, {{ $col.LName }} {{ NotNullScanType $col }}{{ end }}, lock bool) (*{{ $uname }}, error){
  tr := {{ $uname }}{}
  if err := selectTRCond(ctx, q, &tr, lock, "1{{ range $col := $index.Columns }} AND `{{ $col.ColumnName }}`=?{{ end }}",
    {{- range $col := $index.Columns -}}
    {{ $col.LName }},
    {{- end -}}
  ); err != nil {
    return nil, err
  }
  return &tr, nil
}
{{ end -}}
{{ end }}

// nxPreScan appends all columns to dest for scanning. Implements ColumnScanner interface.
func (tr *nxNull{{ $uname }}) nxPreScan(dest *[]interface{}) {
  *dest = append(*dest,
  {{ range $i, $col := .Table.Columns -}}
  {{ if $col.Nullable -}}
    &tr.ordinary.{{ $col.UName }},
  {{ else -}}
    &tr.null{{ $col.UName }},
  {{ end -}}
  {{ end -}}
  )
}

// nxPostScan must be called after scanning to do some extra processsing. Implements ColumnScanner interface.
func (tr *nxNull{{ $uname }}) nxPostScan() error {

  var nullCol string

  {{ range $col := .Table.Columns -}}
  {{ if not $col.Nullable -}}
  if !tr.null{{ $col.UName }}.Valid {
    nullCol = "{{ $col.ColumnName }}"
    goto CheckNULL
  }
  tr.ordinary.{{ $col.UName }} = tr.null{{ $col.UName }}.{{ Slice (NullScanType $col) 5 }}

  {{ end -}}
  {{ end -}}

  if false {
    // NOTE: Impossible branch to suppress "label CheckNULL defined and not used" error.
    goto CheckNULL
  }

  // All checks passed
  tr.ordinaryPtr = &tr.ordinary
  return nil

CheckNULL:
  if *tr == (nxNull{{ $uname }}{}) {
    // Null row, set ptr to nil.
    tr.ordinaryPtr = nil
    return nil
  }
  return fmt.Errorf("{{ $name }}.%s can't be NULL", nullCol)
}


// Ordinary returns the ordinary {{ $uname }}. It must be called only after nxPostScan.
func (tr *nxNull{{ $uname }}) Ordinary() *{{ $uname }} {
  return tr.ordinaryPtr
}

func (slice *nx{{ $uname }}Slice) nxLen() int {
  return len(*slice)
}

func (slice *nx{{ $uname }}Slice) nxItem(i int) interface{} {
  return (*slice)[i]
}

func (slice *nx{{ $uname }}Slice) nxAppend(item interface{}) {
  obj := (*{{ $uname }})(nil)
  if item != nil {
    obj = item.(*{{ $uname }})
  }
  *slice = append(*slice, obj)
}

