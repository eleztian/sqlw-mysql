package {{ .PackageName }}


import (
  "context"
  "fmt"
  "time"

  "gopkg.in/volatiletech/null.v6"
)

// Suppress not used errors.
var (
  _ = context.Background
  _ = fmt.Printf
  _ = time.Now
  _ = null.NewBool
)

{{ $name := .Table.TableName }}
{{ $upper := UpperCamel .Table.TableName }}
{{ $lower := LowerCamel .Table.TableName }}

// {{ $upper }} represents a row of table `{{ $name }}`.
type {{ $upper }} struct {
  {{ range $col := .Table.Columns -}}
  {{ UpperCamel $col.ColumnName }} {{ ScanType $col }} `json:"{{ $col.ColumnName }}" db:"{{ $col.ColumnName }}"`
  {{ end -}}
}

// nx{{ $upper }}Slice is slice of {{ $upper }}.
type nx{{ $upper }}Slice []*{{ $upper }}

// nxNull{{ $upper }} is nullable version of {{ $upper }}. It's mainly used for scanning row which maybe NULL (e.g. in outer join).
type nxNull{{ $upper }} struct {
  ordinary {{ $upper }}
  {{ range $col := .Table.Columns -}}{{ if not $col.Nullable -}}
  null{{ UpperCamel $col.ColumnName }} {{ NullScanType $col }}
  {{ end -}}{{ end -}}
}

{{ if .Table.Primary.Valid -}}
// nx{{ $upper }}PrimaryValue is the primary value of {{ $upper }}.
type nx{{ $upper }}PrimaryValue struct {
  {{ range $col := .Table.Primary.Columns -}}
  {{ UpperCamel $col.ColumnName }} {{ ScanType $col }}
  {{ end -}}
}
{{ end }}

var (
  nx{{ $upper }}Meta = NewTableMeta(
    "{{ $name }}",
    []string{ {{- range $col := .Table.Columns }}"{{ $col.ColumnName }}", {{ end -}} },
    OptColumnsWithDefault({{ range $col := .Table.Columns }}{{ if $col.HasDefaultValue }}"{{ $col.ColumnName }}", {{ end }}{{ end }}),
    {{ if .Table.Primary.Valid -}}
    OptPrimaryColumns({{ range $col := .Table.Primary.Columns }}"{{ $col.ColumnName }}", {{ end }}),
    {{ end -}}
    {{ if .Table.AutoIncColumn.Valid -}}
    OptAutoIncColumn("{{ .Table.AutoIncColumn.ColumnName }}"),
    {{ end -}}
  )
)

// TableMeta returns the table meta information of table `{{ $name }}`.
func (tr *{{ $upper }}) TableMeta() *TableMeta {
  return nx{{ $upper }}Meta
}

// Valid returns true if tr is not nil.
func (tr *{{ $upper }}) Valid() bool {
  return tr != nil
}

// ColumnValues implements `TableRow` interface.
func (tr *{{ $upper }}) ColumnValues(dest *[]interface{}, pos ...int) []interface{} {
  if dest == nil {
    n := len(pos)
    if n == 0 {
      n = {{ .Table.NumColumn }}
    }
    buf := make([]interface{}, 0, n)
    dest = &buf
  }
  l := len(*dest)

  if len(pos) == 0 {
    *dest = append(*dest,
    {{ range $col := .Table.Columns -}}
      tr.{{ UpperCamel $col.ColumnName }},
    {{ end -}}
    )
  } else {
    for _, p := range pos {
      switch p {
      {{ range $i, $col := .Table.Columns -}}
      case {{ $i }}:
        *dest = append(*dest, tr.{{ UpperCamel $col.ColumnName }})
      {{ end -}}
      default:
        panic(fmt.Errorf("{{ $upper }}.ColumnValues: %d out of range", p))
      }
    }
  }

  return (*dest)[l:]
}

// ColumnPointers implements `TableRow` interface.
func (tr *{{ $upper }}) ColumnPointers(dest *[]interface{}, pos ...int) []interface{} {
  if dest == nil {
    n := len(pos)
    if n == 0 {
      n = {{ .Table.NumColumn }}
    }
    buf := make([]interface{}, 0, n)
    dest = &buf
  }
  l := len(*dest)

  if len(pos) == 0 {
    *dest = append(*dest,
    {{ range $col := .Table.Columns -}}
      &tr.{{ UpperCamel $col.ColumnName }},
    {{ end -}}
    )
  } else {
    for _, p := range pos {
      switch p {
      {{ range $i, $col := .Table.Columns -}}
      case {{ $i }}:
        *dest = append(*dest, &tr.{{ UpperCamel $col.ColumnName }})
      {{ end -}}
      default:
        panic(fmt.Errorf("{{ $upper }}.ColumnPointers: %d out of range", p))
      }
    }
  }

  return (*dest)[l:]
}

{{ if .Table.Primary.Valid -}}
// PrimaryValue implements `TableRowWithPrimary` interface.
// It returns nil if `tr` is nil.  
func (tr *{{ $upper }}) PrimaryValue() interface{} {
  if tr == nil {
    return nil
  }
  return nx{{ $upper }}PrimaryValue{
    {{ range $col := .Table.Primary.Columns -}}
    {{ UpperCamel $col.ColumnName }}: tr.{{ UpperCamel $col.ColumnName }},
    {{ end -}}
  }
}
{{ end -}}

// Insert is used to insert this row into table.
// NOTE: This method does not modify content in `tr` except auto increment column (if exists).
{{ if .Table.Primary.Valid -}}
// Use Reload to get the newest data from database.
{{ end -}}
func (tr *{{ $upper }}) Insert(ctx context.Context, e Execer) error {
  return InsertTR(ctx, e, tr)
}

{{ if .Table.Primary.Valid -}}
// Reload is used to reload this row from table.
func (tr *{{ $upper }}) Reload(ctx context.Context, q Queryer) error {
  return SelectTR(ctx, q, tr, false)
}
{{ end }}

{{ if .Table.Primary.Valid -}}
// ReloadWithLock is used to reload this row with lock from table.
func (tr *{{ $upper }}) ReloadWithLock(ctx context.Context, q Queryer) error {
  return SelectTR(ctx, q, tr, true)
}
{{ end }}

{{ if .Table.Primary.Valid -}}
// Update is used to update this row in table. Only columns with different values will be updated.
// NOTE: This method does not modify content in `tr`/`newTr`. 
// Use Reload to get the newest data from database.
func (tr *{{ $upper }}) Update(ctx context.Context, e Execer, newTr *{{ $upper }}) error {
  return UpdateTR(ctx, e, tr, newTr)
}
{{ end }}

{{ if .Table.Primary.Valid -}}
// Delete is used to delete this row from table.
func (tr *{{ $upper }}) Delete(ctx context.Context, e Execer) error {
  return DeleteTR(ctx, e, tr)
}
{{ end }}

// Copy this row.
func (tr *{{ $upper }}) Copy() *{{ $upper }} {
  ret := &{{ $upper }}{}
  *ret = *tr
  return ret
}

{{ range $index := .Table.Indices -}}
{{ if $index.IsUnique -}}
// {{ $upper }}By{{ UpperCamel $index.IndexName }} is used to select `{{ $name }}` row by key `{{ $index.IndexName }}`.
func {{ $upper }}By{{ UpperCamel $index.IndexName }}(ctx context.Context, q Queryer{{ range $col := $index.Columns }}, {{ LowerCamel $col.ColumnName }} {{ NotNullScanType $col }}{{ end }}, lock bool) (*{{ $upper }}, error){
  tr := {{ $upper }}{}
  if err := SelectTRCond(ctx, q, &tr, lock, "1{{ range $col := $index.Columns }} AND `{{ $col.ColumnName }}`=?{{ end }}",
    {{- range $col := $index.Columns -}}
    {{ LowerCamel $col.ColumnName }},
    {{- end -}}
  ); err != nil {
    return nil, err
  }
  return &tr, nil
}
{{ end -}}
{{ end }}

func (slice *nx{{ $upper }}Slice) Len() int {
  return len(*slice)
}

func (slice *nx{{ $upper }}Slice) Item(i int) interface{} {
  return (*slice)[i]
}

func (slice *nx{{ $upper }}Slice) Append(item interface{}) {
  obj := (*{{ $upper }})(nil)
  if item != nil {
    obj = item.(*{{ $upper }})
  }
  *slice = append(*slice, obj)
}

func (tr *nxNull{{ $upper }}) ColumnPointers(dest *[]interface{}) {
  *tr = nxNull{{ $upper }}{}
  *dest = append(*dest,
  {{ range $i, $col := .Table.Columns -}}
  {{ if $col.Nullable -}}
    &tr.ordinary.{{ UpperCamel $col.ColumnName }},
  {{ else -}}
    &tr.null{{ UpperCamel $col.ColumnName }},
  {{ end -}}
  {{ end -}}
  )
}

func (tr *nxNull{{ $upper }}) Ordinary() (*{{ $upper }}, error) {

  var nullCol string

  {{ range $col := .Table.Columns -}}
  {{ if not $col.Nullable -}}
  if !tr.null{{ UpperCamel $col.ColumnName }}.Valid {
    nullCol = "{{ $col.ColumnName }}"
    goto CheckNULL
  }
  tr.ordinary.{{ UpperCamel $col.ColumnName }} = tr.null{{ UpperCamel $col.ColumnName }}.{{ Slice (NullScanType $col) 5 }}

  {{ end -}}
  {{ end -}}

  if false {
    // NOTE: Impossible branch to suppress "label CheckNULL defined and not used" error.
    goto CheckNULL
  }
  return &tr.ordinary, nil

CheckNULL:
  if *tr == (nxNull{{ $upper }}{}) {
    return nil, nil
  }
  return nil, fmt.Errorf("{{ $name }}.%s can't be NULL", nullCol)
}
