package {{ .PackageName }}

import (
	"fmt"
)

// Tst1 is test TableRow with two-column primary key.
type Tst1 struct {
	c1 string
	p2 int32
	p1 int32
	a1 int32
}

// Tst2 is test TableRow without primary key.
type Tst2 struct {
	c1 string
	c2 int32
}

type tst1PrimaryValue struct {
	p1 int32
	p2 int32
}

var (
	_ TableRow            = (*Tst1)(nil)
	_ TableRowWithPrimary = (*Tst1)(nil)
	_ TableRow            = (*Tst2)(nil)
)

func (tr *Tst1) nxPreScan(dest *[]interface{}) {
	*dest = append(*dest, &tr.c1, &tr.p2, &tr.p1, &tr.a1)
}

func (tr *Tst1) nxPostScan() error {
	return nil
}

var (
	tst1Meta = NewTableMeta(
		"tst1",
		[]string{"c1", "p2", "p1", "a1"},
		OptPrimaryColumns("p1", "p2"),
		OptColumnsWithDefault("p1", "a1"),
		OptAutoIncColumn("a1"),
	)
)

func (tr *Tst1) TableMeta() *TableMeta {
	return tst1Meta
}

func (tr *Tst1) Valid() bool {
	return tr != nil
}

func (tr *Tst1) ColumnValue(i int) interface{} {
	switch i {
	case 0:
		return tr.c1
	case 1:
		return tr.p2
	case 2:
		return tr.p1
	case 3:
		return tr.a1
	default:
		panic(fmt.Errorf("%d is out of range", i))
	}
}

func (tr *Tst1) ColumnPointer(i int) interface{} {
	switch i {
	case 0:
		return &tr.c1
	case 1:
		return &tr.p2
	case 2:
		return &tr.p1
	case 3:
		return &tr.a1
	default:
		panic(fmt.Errorf("%d is out of range", i))
	}
}

func (tr *Tst1) PrimaryValue() interface{} {
	if tr == nil {
		return nil
	}
	return tst1PrimaryValue{
		p1: tr.p1,
		p2: tr.p2,
	}
}

func (tr *Tst2) nxPreScan(dest *[]interface{}) {
	*dest = append(*dest, &tr.c1, &tr.c2)
}

func (tr *Tst2) nxPostScan() error {
	return nil
}

var (
	tst2Meta = NewTableMeta(
		"tst2",
		[]string{"c1", "c2"},
	)
)

func (tr *Tst2) TableMeta() *TableMeta {
	return tst2Meta
}

func (tr *Tst2) Valid() bool {
	return tr != nil
}

func (tr *Tst2) ColumnValue(i int) interface{} {
	switch i {
	case 0:
		return tr.c1
	case 1:
		return tr.c2
	default:
		panic(fmt.Errorf("%d is out of range", i))
	}
}

func (tr *Tst2) ColumnPointer(i int) interface{} {
	switch i {
	case 0:
		return &tr.c1
	case 1:
		return &tr.c2
	default:
		panic(fmt.Errorf("%d is out of range", i))
	}
}
