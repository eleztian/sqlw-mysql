package {{ .PackageName }}

import (
	"context"
	"fmt"
	"strings"
	"time"

	"gopkg.in/volatiletech/null.v6"
	"gopkg.in/volatiletech/null.v6/convert"
)

// TableRow represents a table's row.
type TableRow interface {
	// TableMeta returns the table's meta information.
	TableMeta() *TableMeta

	// Valid returns true if this is a valid table row.
	Valid() bool

	// ColumnValuer returns the i-th column as valuer.
	ColumnValuer(i int) interface{}

	// ColumnScanner returns the i-th column as scanner. (e.g. pointer)
	ColumnScanner(i int) interface{}
}

// TableMeta contains meta information of a database table.
type TableMeta struct {
	// Basic information.
	tableName   string
	columnNames []string // column pos -> column name

	// Optinal information.
	primaryColumnsPos []int  // len(primaryColumnsPos) == 0 if the table has no primary key
	autoIncColumnPos  int    // autoIncColumnPos == -1 if the table has no auto increment column
	hasDefault        []bool // len(hasDefault) == len(columnNames), true if the column has not NULL server side default

	// Pre calculate information.
	columnsPos map[string]int // column name -> column pos

	// Post calculate information.
	isPrimary   []bool // column pos -> true if the column is part of primary key
	primaryCond string // "`id1`=? AND `id2`=? ..."
	selectQuery string // "SELECT `col`, .... FROM `xxx` WHERE ..."
	deleteQuery string // "DELETE FROM `xxx` WHERE ..."
}

// TableMetaOption is used in creating TableMeta.
type TableMetaOption func(*TableMeta)

// OptColumnsWithDefault sets the columns that have not NULL server side default, including:
//  - AUTO_INCREMENT
//  - NOW()
//  - Other not NULL constant defaults.
func OptColumnsWithDefault(columnNames ...string) TableMetaOption {
	return func(meta *TableMeta) {
		for _, columnName := range columnNames {
			pos, ok := meta.columnsPos[columnName]
			if !ok {
				panic(fmt.Errorf("Table `%s` has no column named `%s`", meta.tableName, columnName))
			}
			meta.hasDefault[pos] = true
		}
	}
}

// OptPrimaryColumns sets the primary key columns.
func OptPrimaryColumns(columnNames ...string) TableMetaOption {
	return func(meta *TableMeta) {
		for _, columnName := range columnNames {
			pos, ok := meta.columnsPos[columnName]
			if !ok {
				panic(fmt.Errorf("Table `%s` has no column named `%s`", meta.tableName, columnName))
			}
			meta.primaryColumnsPos = append(meta.primaryColumnsPos, pos)
		}
	}
}

// OptAutoIncColumn sets the auto increment column.
func OptAutoIncColumn(columnName string) TableMetaOption {
	return func(meta *TableMeta) {
		pos, ok := meta.columnsPos[columnName]
		if !ok {
			panic(fmt.Errorf("Table `%s` has no column named `%s`", meta.tableName, columnName))
		}
		meta.autoIncColumnPos = pos
	}
}

// NewTableMeta creates a new TableMeta.
func NewTableMeta(tableName string, columnNames []string, opts ...TableMetaOption) *TableMeta {
	meta := &TableMeta{
		tableName:         tableName,
		columnNames:       columnNames,
		primaryColumnsPos: nil,
		autoIncColumnPos:  -1,
		hasDefault:        make([]bool, len(columnNames)), // All false
		columnsPos:        make(map[string]int),
		isPrimary:         make([]bool, len(columnNames)), // All false
	}
	for i, columnName := range columnNames {
		meta.columnsPos[columnName] = i
	}
	for _, opt := range opts {
		opt(meta)
	}
	meta.postCalculate()
	return meta
}

// TableName returns the table name.
func (meta *TableMeta) TableName() string {
	return meta.tableName
}

// Insert a row into table. Rule:
//   - If column has non zero value, then this column will be inserted.
//   - Othewise if the column has no server-side default, this column will be inserted.
func (meta *TableMeta) Insert(ctx context.Context, e Execer, tr TableRow) error {

	meta.checkTableMeta(tr)

	cols := []string{}
	phs := []string{}
	vals := []interface{}{}

	// Choose columns to insert.
	for i, col := range meta.columnNames {
		val := tr.ColumnValuer(i)
		if isZero(val) && meta.hasDefault[i] {
			// Skip column value that is zero value and has not null default.
			continue
		}
		cols = append(cols, col)
		phs = append(phs, "?")
		vals = append(vals, val)
	}

	// Construct query.
	query := ""
	if len(cols) == 0 {
		query = fmt.Sprintf("INSERT INTO `%s` () VALUES ()", meta.tableName)
	} else {
		query = fmt.Sprintf("INSERT INTO `%s` (`%s`) VALUES (%s)", meta.tableName, strings.Join(cols, "`, `"), strings.Join(phs, ", "))
	}

	// Query.
	result, err := e.ExecContext(ctx, query, vals...)
	if err != nil {
		return err
	}

	// If has auto increment column and the column's value is zero.
	if meta.autoIncColumnPos >= 0 && isZero(tr.ColumnValuer(meta.autoIncColumnPos)) {
		lastInsertId, err := result.LastInsertId()
		if err != nil {
			return err
		}
		if err := convert.ConvertAssign(tr.ColumnScanner(meta.autoIncColumnPos), lastInsertId); err != nil {
			return err
		}
	}

	return nil

}

// Update a row in table. The table must have primary key, otherwise a panic will be raised. Rule:
//   - Only columns that have different values will be updated.
func (meta *TableMeta) Update(ctx context.Context, e Execer, tr, newTr TableRow) error {

	meta.checkTableMeta(tr)
	meta.checkTableMeta(newTr)

	// Get primary values.
	primVals, err := meta.primaryVals(tr)
	if err != nil {
		return err
	}

	asgmts := []string{}
	asgmtsVals := []interface{}{}

	// Choose columns to update.
	for i, col := range meta.columnNames {

		if meta.isPrimary[i] {
			// Skip primary column.
			continue
		}

		val := tr.ColumnValuer(i)
		newVal := newTr.ColumnValuer(i)
		if val == newVal {
			// Skip if no difference.
			continue
		}

		asgmts = append(asgmts, fmt.Sprintf("`%s`=?", col))
		asgmtsVals = append(asgmtsVals, newVal)

	}

	// Nothing to update.
	if len(asgmtsVals) == 0 {
		return nil
	}

	// Construct query.
	query := fmt.Sprintf("UPDATE `%s` SET %s WHERE %s", meta.tableName, strings.Join(asgmts, ", "), meta.primaryCond)

	// Query.
	// NOTE: The meaning of affected rows is ambiguous so just discard it.
	_, err = e.ExecContext(ctx, query, append(asgmtsVals, primVals...)...)
	return err

}

// Delete a row in table. The table must have primary key, otherwise a panic will be raised.
func (meta *TableMeta) Delete(ctx context.Context, e Execer, tr TableRow) error {

	meta.checkTableMeta(tr)

	// Get primary values.
	primVals, err := meta.primaryVals(tr)
	if err != nil {
		return err
	}

	// Query.
	_, err = e.ExecContext(ctx, meta.deleteQuery, primVals...)
	return err
}

// Select a row in table. The table must have primary key, otherwise a panic will be raised.
// It returns no error if a row is successfully found and returned.
func (meta *TableMeta) Select(ctx context.Context, q Queryer, tr TableRow, lock bool) error {

	meta.checkTableMeta(tr)

	// Get primary values.
	primVals, err := meta.primaryVals(tr)
	if err != nil {
		return err
	}

	// Construct query.
	query := meta.selectQuery
	if lock {
		query += " FOR UPDATE"
	}

	// Prepare result.
	result := make([]interface{}, 0, len(meta.columnNames))
	for i, _ := range meta.columnNames {
		result = append(result, tr.ColumnScanner(i))
	}

	// Query.
	row := q.QueryRowContext(ctx, query, primVals...)
	return row.Scan(result...)

}

func (meta *TableMeta) checkTableMeta(tr TableRow) {
	if tr.TableMeta() != meta {
		panic(fmt.Errorf("Expect table `%s`'s row but got `%s`", meta.tableName, tr.TableMeta().tableName))
	}
}

func (meta *TableMeta) primaryVals(tr TableRow) ([]interface{}, error) {
	meta.checkTableMeta(tr)
	if len(meta.primaryColumnsPos) == 0 {
		panic(fmt.Errorf("Table `%s` has no primary key", meta.tableName))
	}

	vals := []interface{}{}
	for _, pos := range meta.primaryColumnsPos {
		val := tr.ColumnValuer(pos)
		if isZero(val) {
			return nil, fmt.Errorf("Table `%s` row has null primary key", meta.tableName)
		}
		vals = append(vals, val)
	}

	return vals, nil
}

func (meta *TableMeta) postCalculate() {
	if len(meta.primaryColumnsPos) == 0 {
		return
	}

	// isPrimary
	for _, pos := range meta.primaryColumnsPos {
		meta.isPrimary[pos] = true
	}

	// primaryCond
	conds := []string{}
	for _, pos := range meta.primaryColumnsPos {
		conds = append(conds, fmt.Sprintf("`%s`=?", meta.columnNames[pos]))
	}
	meta.primaryCond = strings.Join(conds, " AND ")

	// selectQuery
	cols := []string{}
	for _, columnName := range meta.columnNames {
		cols = append(cols, fmt.Sprintf("`%s`", columnName))
	}
	meta.selectQuery = fmt.Sprintf("SELECT %s FROM `%s` WHERE %s", strings.Join(cols, ", "), meta.tableName, meta.primaryCond)

	// deleteQuery
	meta.deleteQuery = fmt.Sprintf("DELETE FROM `%s` WHERE %s", meta.tableName, meta.primaryCond)

}

func isZero(val interface{}) bool {

	switch v := val.(type) {
	case float32:
		return v == 0
	case float64:
		return v == 0
	case bool:
		return v == false
	case int8:
		return v == 0
	case int16:
		return v == 0
	case int32:
		return v == 0
	case int64:
		return v == 0
	case uint8:
		return v == 0
	case uint16:
		return v == 0
	case uint32:
		return v == 0
	case uint64:
		return v == 0
	case time.Time:
		return v.IsZero()
	case string:
		return v == ""
	case null.Float32:
		return !v.Valid
	case null.Float64:
		return !v.Valid
	case null.Bool:
		return !v.Valid
	case null.Int8:
		return !v.Valid
	case null.Int16:
		return !v.Valid
	case null.Int32:
		return !v.Valid
	case null.Int64:
		return !v.Valid
	case null.Uint8:
		return !v.Valid
	case null.Uint16:
		return !v.Valid
	case null.Uint32:
		return !v.Valid
	case null.Uint64:
		return !v.Valid
	case null.Time:
		return !v.Valid
	case null.String:
		return !v.Valid
	default:
		panic(fmt.Errorf("isZero: Not support test for type %T", val))
	}

}
